import { AfterSuccessContext, AfterSuccessHook, Awaitable, BeforeRequestContext, BeforeRequestHook, Hooks } from "./types";
export declare class PrefixApiKeyBeforeRequestHook implements BeforeRequestHook {
    beforeRequest(hookCtx: BeforeRequestContext, request: Request): Awaitable<Request>;
}
/**
 * Some of our APIs return null for values when they really should return nothing.  Since JS distinguishes between
 * null and undefined AND Zod is very stringent, null values cause the serialization to explode when a null is received.
 * While we could mark fields as 'nullable', there are a couple of reasons this is not ideal
 *   1. there's no way to predict which fields will potentially return null, so every non-required field would need to
 *   be marked nullable
 *   2. other SDKs without a strict difference between null and undefined need to account for this difference when a
 *   schema field is nullable; that is, it would make most of the other SDKs harder to use
 *   3. we don't have any instance where null is different from undefined.  for example, a null field in an API could
 *   be used to clear out a value during a PATCH request - but we don't have a single example of this in our 2018 API
 * So, instead of jumping through hoops, we use this hook to drop any fields with null values.
 */
export declare class ConvertNullToUndefinedAfterSuccessHook implements AfterSuccessHook {
    private deleteKeysWithNullValues;
    private isResponseJson;
    afterSuccess(hookCtx: AfterSuccessContext, response: Response): Promise<Response>;
}
export declare function initHooks(hooks: Hooks): void;
//# sourceMappingURL=registration.d.ts.map